package hu.bme.mit.ttc.imdb.queries

import "http://movies/1.0"

// Task 2

pattern personName(p, pName) {
	Person.name(p, pName);
}

/* 
// Couples
pattern playedTogetherIn(p1name, p2name, m) {
	Person.movies(p1, m);
	Movie.persons(m, p2);

	find personName(p1, p1name);
	find personName(p2, p2name);

	check(p1name < p2name);
}*/

pattern personsToCouple(p1name, p2name) {
	Person.movies(P1, M1);
	Person.movies(P2, M1);
	
	Person.movies(P1, M2);
	Person.movies(P2, M2);
	
	Person.movies(P1, M3);
	Person.movies(P2, M3);
	
	M1 != M2;
	M2 != M3;
	M1 != M3;
	
	Person.name(P1, p1name);
	Person.name(P2, p2name);
	check(p1name < p2name);
	
	// V1
//	find playedTogetherIn(p1name, p2name, m1);
//	find playedTogetherIn(p1name, p2name, m2);
//	find playedTogetherIn(p1name, p2name, m3);
//	m1 != m2;
//	m2 != m3;
//	m1 != m3;

	// V2
//	find playedTogetherIn(p1name, p2name, _anymovie);
//	N == count find playedTogetherIn(p1name, p2name, _m);
//	check(N >= 3);
}

@QueryExplorer(display = false)
pattern commonMoviesToCouple(p1name, p2name, m) {
	find personsToCouple(p1name, p2name);
	
	Person.movies(p1, m);
	Person.movies(p2, m);
	Person.name(p1,p1name);
	Person.name(p2,p2name);

	check(p1name < p2name);
}

// Task 3
// Average rankings
@QueryExplorer(display = false)
pattern couple(c, p1, p2) {
	Couple.p1(c, p1);
	Couple.p2(c, p2);
}

//pattern coupleWithRating(p1, p2, avgRating) {
//	find couple(c, p1, p2);
//	Couple.avgRating(c, avgRating);	
//}

// Extension Task 1
// Top-15 Couples
@QueryExplorer(display = false)
pattern commonMoviesOfCouple(c, m) {
	Couple.commonMovies(c, m);
}

@QueryExplorer(display = false)
pattern coupleWithRating(c, avgRating) {
	Couple.avgRating(c, avgRating);
}

@QueryExplorer(display = false)
pattern countOfCommonMoviesOfCouple(p1, p2, n) {
	find couple(c, p1, p2);
	n == count find commonMoviesOfCouple(c, _m);
}

// Extension Task 2
// Clique
@QueryExplorer(display = false)
pattern commonMoviesOfGroup(g, m) {
	Group.commonMovies(g, m);
}

// Groups
@QueryExplorer(display = false)
pattern group(g) {
	Group(g);
}

// a Group is either a Couple or a Clique
@QueryExplorer(display = false)
pattern memberOfGroup(p, g) {
	Couple.p1(g, p);
} or {
	Couple.p2(g, p);
} or {
	Clique.persons(g, p);
}

@QueryExplorer(display = false)
pattern commonMovieOfGroupAndPerson(g, p, m) {
	find commonMoviesOfGroup(g, m);
	Person.movies(p, m);
}

@QueryExplorer(display = false)
pattern nextCliques(g : Group, p : Person) {
	find commonMovieOfGroupAndPerson(g, p, m1);
	find commonMovieOfGroupAndPerson(g, p, m2);
	find commonMovieOfGroupAndPerson(g, p, m3);
	m1 != m2;
	m2 != m3;
	m1 != m3;
	neg find alphabeticallyLaterMemberOfGroup(g, p);
}

// this also filters the person in the parameter
@QueryExplorer(display = false)
pattern alphabeticallyLaterMemberOfGroup(g : Group, p : Person) {
	find memberOfGroup(m, g);
	find personName(p, pName);
	find personName(m, mName);
	check(mName >= pName);
}


// alternative nextClique to avoid decart product in alphabeticallyLater 
@QueryExplorer(display = false)
pattern nextCliques2(g : Group, p : Person) {
	find commonMovieOfGroupAndPerson(g, p, m1);
	find commonMovieOfGroupAndPerson(g, p, m2);
	find commonMovieOfGroupAndPerson(g, p, m3);
	m1 != m2;
	m2 != m3;
	m1 != m3;
	find alphabeticallyLatestMemberOfGroup(g, pl);
	find personName(p, pName);
	find personName(pl, plName);
	check(pName >= plName);
}

@QueryExplorer(display = false)
pattern alphabeticallyLatestMemberOfGroup(g : Group, p : Person) {
	find memberOfGroup(p, g);
	neg find alphabeticallyLaterMemberOfGroup2(g, p, _m);
}

@QueryExplorer(display = false)
pattern alphabeticallyLaterMemberOfGroup2(g : Group, p : Person, m : Person) {
	find memberOfGroup(p, g);
	find memberOfGroup(m, g);
	find personName(p, pName);
	find personName(m, mName);
	check(mName >= pName);
}

