package hu.bme.mit.ttc.imdb.queries

import "http://movies/1.0"

// Task 2
pattern playedTogetherIn(p1name, p2name, m) {
	Person.movies(p1, m);
	Movie.persons(m, p2);
	
	find personName(p1, p1name);
	find personName(p2, p2name);

	check(p1name < p2name);
}

pattern personsToCouple(p1name, p2name) {
	find playedTogetherIn(p1name, p2name, _anymovie);
	N == count find playedTogetherIn(p1name, p2name, _m);
	check(N >= 3);
}

pattern personName(p, pName) {
	Person.name(p, pName);
}

pattern commonMoviesToCouple(p1, p2, m) {
	find personsToCouple(p1, p2);
	find playedTogetherIn(p1, p2, m);
}

// Task 3

pattern couple(c, p1, p2) {
	Couple.p1(c, p1);
	Couple.p2(c, p2);	
}

//pattern coupleWithRating(p1, p2, avgRating) {
//	find couple(c, p1, p2);
//	Couple.avgRating(c, avgRating);	
//}

// Extension Task 1
pattern commonMoviesOfCouple(c, m) {
	Couple.commonMovies(c, m);
}

pattern coupleWithRating(c, avgRating) {
	Couple.avgRating(c, avgRating);	
}


// Extension Task 1 a)



// Extension Task 1 b)

pattern countOfCommonMoviesOfCouple(p1, p2, n) {
	find couple(c, p1, p2);
	n == count find commonMoviesOfCouple(c, _m);
}

// Extension Task 2
pattern commonMoviesOfGroup(g, m) {
	Group.commonMovies(g, m);
}

// a Group is either a Couple or a Clique
pattern memberOfGroup(p, g) {
	Couple.p1(g, p);
} or {
	Couple.p2(g, p);
} or {
	Clique.persons(g, p);
}

pattern commonMovieOfGroupAndPerson(g, p, m) {
	find commonMoviesOfGroup(g, m);
	Person.movies(p, m);
}

pattern nextCliques(g : Group, p : Person)  {
	neg find alphabeticallyLaterMemberOfGroup(g, p);
	n == count find commonMovieOfGroupAndPerson(g, p, m);
	check(n >= 3);
//	neg find union(g, p);
}

//pattern subsetOfGroup(g0 : Group, gx : Group) {
//	neg find x(p0, g0, gx);
//}
//
//pattern x(p0 : Person, g0 : Group, gx : Group) {
//	find memberOfGroup(p0, g0);
//	neg find memberOfGroup(p0, gx);
//}
//
//pattern union(g0, p) {
//	find memberOfGroup(p, gx);
//	find subsetOfGroup(g0, gx);
//}



// this also filters the person in the argument
pattern alphabeticallyLaterMemberOfGroup(g : Group, p : Person)  {
	find memberOfGroup(m, g);
	Person.name(p, pName);
	Person.name(m, mName);
	check(mName >= pName);
}


